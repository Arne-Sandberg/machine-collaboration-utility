const Promise = require('bluebird');
const uuidGenerator = require('uuid/v4');
const StateMachine = require('javascript-state-machine');
const Stopwatch = require('timer-stopwatch');
const bsync = require('asyncawait/async');
const bwait = require('asyncawait/await');

const jobFsmDefinitions = require('../../../react/modules/Jobs/jobFsmDefinitions');
const jobModel = require('./model');

/**
 * Job()
 *
 * A Job object represents the execution of a file by a bot
 * The Job maintains its state, as well as info about the bot and file being used
 *
 * @param {string} app - The entire React app as rendered by the server
 * @param {object} botUuid - The uuid of the bot to be linked to this job
 * @param {object} fileUuid - The uuid of the file to be linked to this job
 * @param {object} initialState - Passed in case of restoring an old job
 * @param {object} id - The ID for the job as provided by the sql database
 * @param {object} subscribers - Array of endpoints that want to receie updates when job events occur
 * @param {object} jobUuid - Job uuid will be autogenerated
 *                           however the user can instead force a specific uuid instead
 *
 * @returns {Object} - A new Job object
 */
const Job = function Job(jobParams) {
  this.app = jobParams.app;
  this.botUuid = jobParams.botUuid;
  this.fileUuid = jobParams.fileUuid;
  this.uuid = jobParams.jobUuid !== undefined ? jobParams.jobUuid : uuidGenerator();

  this.initialState = jobParams.initialState;
  this.id = jobParams.id;
  this.subscribers = Array.isArray(jobParams.subscribers) ? jobParams.subscribers : [];
  this.logger = this.app.context.logger;
};

/**
 * initialize()
 *
 * Once the job object is created, it needs to set up its uuid, state machine,
 * stopwatch functionality, etc.
 *
 */
Job.prototype.initialize = bsync(function initialize() {
  const self = this;

  this.JobModel = bwait(jobModel(this.app));
  if (this.botUuid === undefined) {
    throw new Error('"botUuid" is not defined');
  }

  let initialState;
  if (self.initialState === 'complete' || self.initialState === 'canceled') {
    initialState = self.initialState;
  } else if (self.initialState === undefined) {
    initialState = 'initializing';
  } else {
    // If a job was canceled while running, set it to canceled
    // TODO Update it permanently to have a state of canceled in the database
    initialState = 'canceled';
  }

  const fsmSettings = {
    initial: initialState,
    error: (eventName, from, to, args, errorCode, errorMessage) => {
      const fsmError = `Invalid job ${self.uuid} state change on event "${eventName}" from "${from}" to "${to}"\nargs: "${args}"\nerrorCode: "${errorCode}"\nerrorMessage: "${errorMessage}"`;
      self.logger.error(fsmError);
      throw new Error(fsmError);
    },
    events: jobFsmDefinitions.fsmEvents,
    callbacks: {
      onenterstate: bsync((event, from, to) => {
        self.logger.info(`Job ${self.uuid} Bot ${self.botUuid} event ${event}: Transitioning from ${from} to ${to}.`);
        if (from !== 'none') {
          if (event.indexOf('Done') !== -1) {
            try {
              // As soon as an event successfully transistions, update it in the database
              const dbJob = bwait(self.JobModel.findById(self.id));
              bwait(Promise.delay(0)); // For some reason this can't happen in the same tick
              bwait(dbJob.updateAttributes({
                state: self.fsm.current,
                fileUuid: self.fileUuid,
                started: self.started,
                elapsed: self.stopwatch.ms,
                percentComplete: self.percentComplete,
              }));
              self.logger.info(`Job event. ${event} for job ${self.uuid} successfully updated to ${self.fsm.current}`);
            } catch (ex) {
              self.logger.info(`Job event ${event} for job ${self.uuid} failed to update: ${ex}`);
            }
          }
          self.logger.info('jobEvent', self.getJob());
          self.app.io.broadcast('jobEvent', {
            uuid: self.uuid,
            event: 'update',
            data: self.getJob(),
          });
        }
      }),
    },
  };

  this.fsm = StateMachine.create(fsmSettings);
  this.stopwatch = new Stopwatch(false, { refreshRateMS: 10000 });
  this.started = undefined;
  this.elapsed = undefined;
  this.percentComplete = 0;

  // job updates once a second
  this.stopwatch.onTime(() => {
    this.logger.info('jobEvent', this.getJob());
    this.app.io.broadcast('jobEvent', {
      uuid: this.uuid,
      event: 'update',
      data: this.getJob(),
    });
  });
  if (this.fsm.current === 'initializing') {
    this.fsm.initializationDone();
  }
});

/**
 * processCommand()
 *
 * A command is passed to the job.
 *
 * @param {String} command - The command to be processed by the job
 *
 * @returns {Object} - The job object, directly after the job command has been processed
 */
Job.prototype.processCommand = bsync(function processCommand(command) {
  let commandReply;
  switch (command) {
    case 'start':
      bwait(this.start());
      commandReply = this.getJob();
      break;
    case 'pause':
      bwait(this.pause());
      commandReply = this.getJob();
      break;
    case 'resume':
      bwait(this.resume());
      commandReply = this.getJob();
      break;
    case 'cancel':
      bwait(this.cancel());
      commandReply = this.getJob();
      break;
    default:
      commandReply = `Command ${command} is not supported`;
      throw commandReply;
  }
  return commandReply;
});

 /**
  * getJob()
  *
  * Turn a job object into a REST reply friendly object
  *
  * @returns {Object} - The job object, but filtered to contain only values, no functions
  */
Job.prototype.getJob = function getJob() {
  const state = this.fsm.current ? this.fsm.current : 'ready';
  const started = !!this.started ? this.started : null;
  const elapsed = !!this.started ? this.stopwatch.ms || this.elapsed : null;
  return {
    botUuid: this.botUuid,
    uuid: this.uuid,
    state,
    fileUuid: this.fileUuid === undefined ? false : this.fileUuid,
    started,
    elapsed,
    percentComplete: this.percentComplete,
  };
};

 /**
  * start()
  *
  * Start processing a job
  *
  */
Job.prototype.start = bsync(function start() {
  if (this.fsm.current !== 'ready') {
    throw new Error(`Cannot start job from state ${this.fsm.current}`);
  }

  const bot = this.app.context.bots.botList[this.botUuid];
  try {
    bwait(bot.processCommand('startJob', { job: this }));
    this.started = new Date().getTime();
    bwait(this.stopwatch.start());
    this.fsm.start();
  } catch (ex) {
    const errorMessage = `Job start failure ${ex}`;
    this.logger.error(errorMessage);
  }
});

 /**
  * pause()
  *
  * Pause processing a job
  *
  */
Job.prototype.pause = bsync(function pause(params) {
  if (this.fsm.current === 'paused') {
    return;
  }
  if (this.fsm.current !== 'running') {
    throw new Error(`Cannot pause job from state ${this.fsm.current}`);
  }
  const bot = this.app.context.bots.botList[this.botUuid];
  try {
    console.log('about to pause the bot', bot.getBot());
    bwait(bot.commands.pause(bot, params));
    bwait(this.stopwatch.stop());
    this.fsm.pause();
  } catch (ex) {
    const errorMessage = `Job pause failure ${ex}`;
    this.logger.error(errorMessage);
  }
});

/**
 * resume()
 *
 * Resume processing a job
 *
 */
Job.prototype.resume = bsync(function resume(params) {
  if (this.fsm.current === 'running') {
    return;
  }
  if (this.fsm.current !== 'paused') {
    throw new Error(`Cannot resume job from state ${this.fsm.current}`);
  }
  const bot = this.app.context.bots.botList[this.botUuid];
  try {
    bwait(bot.commands.resume(bot, params));
    bwait(this.stopwatch.start());
    this.fsm.resume();
  } catch (ex) {
    const errorMessage = `Job resume failure ${ex}`;
    this.logger.error(errorMessage);
  }
});

/**
 * cancel()
 *
 * Cancel the processing of a job
 *
 */
Job.prototype.cancel = bsync(function cancel(params) {
  if (!jobFsmDefinitions.metaStates.processingJob.includes(this.fsm.current)) {
    throw new Error(`Cannot cancel job from state "${this.fsm.current}"`);
  }
  const bot = this.app.context.bots.botList[this.botUuid];
  try {
    try {
      bwait(bot.commands.cancel(bot, params));
    } catch (ex) {
      this.logger.error('Bot can\'t be cancelled', ex);
    }
    this.stopwatch.stop();
    this.fsm.cancel();
  } catch (ex) {
    const errorMessage = `Job stop failure ${ex}`;
    this.logger.error(errorMessage);
  }
});

Job.prototype.complete = function complete() {
  this.fsm.completeJob();
  this.stopwatch.stop();
  const bot = this.app.context.bots.botList[this.botUuid];
  setTimeout(() => {
    this.app.io.broadcast('botEvent', {
      uuid: this.botUuid,
      event: 'update',
      data: bot.getBot(),
    });
  }, 2000);
};

module.exports = Job;
